/* TODO list-
  1. move 1 tile function DONE
  2. change encoder loop to function DONE
  3. implement rescue mechanism DONE
  4. Fix wall align using PID DONE
  5. Fix encoder movement using PID DONE
  6. Heated victim DONE
  7. Add basic wall follow algorithm DONE
  8. Depth first search algorithm
  9. Visual victim Identification
  10. Turn 90 degree using mpu6050 DONE
  11. Implement colour sensor DONE
*/

#include "constants.h"
#include "libraries.h"
#include "objects.h"
#include "variables.h"
//#include "Stack.h"

// StackArray <int> stack1;
// StackArray <int> stack2;

// stack.push(s_cell[0]);
// stack.pop();
int tracePath[100];
int count1=0;
void setup() {

  tile *s_cell;
#ifdef DEBUG
  beginSerialUSB();
#else
  delay(100);
#endif

  // Setup Input and Output pins
  setupIO();

  // Enable External interrupts on encoder pins
  attachInterrupt(digitalPinToInterrupt(encoder0PinA), doEncoderR, FALLING);
  attachInterrupt(digitalPinToInterrupt(encoder1PinA), doEncoderL, FALLING);

  beep();

  // Init Servo
  initServo();

  // begin IMU functions
  beginMotion();

  // Calibrate MPU6050
  CalibrateMPU6050(50);

  // setup VL53L0x tof sensors
  setupTOF();

  // begin MLX90614 sensor
  beginMLX();

  // start neopixel
  beginNeopixel();

  // Clear pixels
  clearPixels();

  //begin Oled function
  oledbegin();

  beep();
  // start parallel loops
  Scheduler.startLoop(MLXloop);    // constantly read temperatures
  Scheduler.startLoop(gyroLoop);   // Calculate Gyro roll pitch and yaw reading
  Scheduler.startLoop(bumpLoop);   // detect left and right bumps
  Scheduler.startLoop(colourLoop); // Constantly detect tile colour

  delay(200);
  beep();
  // Wait until a signal is given
  waitForSignal();
}

void loop() {
  clearPixels();
  beep();

  if (cell[p_x][p_y].is_visited==0) {
  update_cell();
  }
  else{
    if(cell[p_x][p_y].is_node==1){
    while(cell[p_x][p_y].h!=head)
    switch (head) {
      case -1:turn90(90, -1, false);
              //heading();
              break;
      case -2:turn90(90, -1, false);
              //heading();
              break;
      case -3:turn90(90, 1, false);
              //heading();
              break;
      case  1:turn90(90, 1, false);
              //heading();
              break;
      case  2:turn90(90, 1, false);
              //heading();
              break;
      case  3:turn90(90,-1, false);
              //heading();
              break;
    }
  }
    if (cell[p_x][p_y].is_visited==1)
    {
      cell[p_x][p_y].is_visited++;
    }
    else if(cell[p_x][p_y].is_visited>=2){
      if(cell[p_x][p_y].is_node==1){
      clearScreen();
      displayPos(0,0,"cur:",p_x,p_y);
      displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
      delay(200);
      turn90(90, -1, false);
      turn90(90, -1, false);
      moveStraight(300);
      heading();
      clearScreen();
      displayPos(0,0,"cur:",p_x,p_y);
      displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
      delay(200);
      do  {
          beep();
          for (int i = 0; i < 8; i++) {
            pixels.setPixelColor(i, pixels.Color(20, 20, 20));
            pixels.show();
          }
          retrace();
        }while(p_x!=0 &&p_y!=0);
        // while (p_x==0 &&p_y==0)) {
        //  for (int i = 0; i < 8; i++) {
        //   pixels.setPixelColor(i, pixels.Color(20, 20, 20));
        //   pixels.show();
        //  }}
      }
    }
  }

  if (cell[p_x][p_y].l == 0) {
    clearScreen();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
    turn90(90, -1, true);
    moveStraight(300);
    heading();
    pr_x = p_x;
    pr_y = p_y;
  } else if (cell[p_x][p_y].f == 0) {
    clearScreen();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
    moveStraight(300);
    pr_x = p_x;
    pr_y = p_y;
    heading();
  }

  else if (cell[p_x][p_y].r == 0) {
    clearScreen();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
    turn90(90, 1, true);
    moveStraight(300);
    pr_x = p_x;
    pr_y = p_y;
    heading();
  } else {
    clearScreen();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
    turn90(90, 1, false);
    turn90(90, 1, true);
    moveStraight(300);
    heading();
    clearScreen();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);

    while(cell[p_x][p_y].is_node==0){
      beep();
      retrace();
    }
    // turn90(90, -1, false);
    if (cell[p_x][p_y].l==0) {
      cell[p_x][p_y].l=1;
    } else if (cell[p_x][p_y].f==0) {
      cell[p_x][p_y].f=1;
    } else if(cell[p_x][p_y].r==0){
      cell[p_x][p_y].r=1;
    }
  }

  count++;
  // pr_x=p_x;
  // pr_y=p_y;
  //heading();
  delay(500);
  yield();
}

void update_cell() {
  cell[p_x][p_y].nos = count;
  cell[p_x][p_y].pre_x = pr_x;
  cell[p_x][p_y].pre_y = pr_y;
  cell[p_x][p_y].h= head;
  if (getDistance(1) < WALLDISTANCE)
    cell[p_x][p_y].f = 1;
  if (getDistance(2) < WALLDISTANCE)
    cell[p_x][p_y].r = 1;
  if (getDistance(0) < WALLDISTANCE)
    cell[p_x][p_y].l = 1;

  check = 0;
  bitWrite(check, 0, cell[p_x][p_y].r);
  bitWrite(check, 1, cell[p_x][p_y].f);
  bitWrite(check, 2, cell[p_x][p_y].l);

  if (check == 0 || check == 1 || check == 2 || check == 4){
    cell[p_x][p_y].is_node = 1;
    for (int i = 0; i < 8; i++) {
      pixels.setPixelColor(i, pixels.Color(0, 20, 20));
      pixels.show();
          }
          delay(100);
          clearPixels();
  }

  if (cell[p_x][p_y].is_visited != 1)
    cell[p_x][p_y].is_visited = 1;
}

void heading() {
  switch (head) {
  case 0:
    p_x++;
    if (p_x > 19) {
      p_x = 0;
    }
    break;
  case 1:
    p_y++;
    if (p_y > 19) {
      p_y = 0;
    }
    break;
  case 2:
    p_x--;
    if (p_x < 0) {
      p_x = 20 + p_x;
    }
    break;
  case 3:
    p_y--;
    if (p_y < 0) {
      p_y = 20 + p_y;
    }
    break;
  }
}


void retrace(){
  //basic Left wall follow
  bool L = (getDistance(LEFT) < WALLDISTANCE) ? true : false;
  bool F = (getDistance(FRONT) < WALLDISTANCE) ? true : false;
  bool R = (getDistance(RIGHT) < WALLDISTANCE) ? true : false;

  indicateWalls();
  delay(300);

  if (!L) {             //left wall open
    indicatePath(LEFT);
    turn90(90, -1,true);
    indicatePath(FRONT);
    moveStraight(300);
    heading();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
  } else if (L && !F && !R) { //wall on left
    indicatePath(FRONT);
    moveStraight(300);
    heading();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
  } else if (L && !F && R) { //wall on left and right
    indicatePath(FRONT);
    moveStraight(300);
    heading();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
  } else if (L && F && !R) { //wall on left and front
    indicatePath(RIGHT);
    turn90(90, 1,true);
    indicatePath(FRONT);
    moveStraight(300);
    heading();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
  } else if (L && F && R) { //all sides closed
    indicatePath(RIGHT);
    turn90(90, 1,true);
    indicatePath(RIGHT);
    turn90(90, 1,true);
    indicatePath(FRONT);
    moveStraight(300);
    heading();
    displayPos(0,0,"cur:",p_x,p_y);
    displayPos(0,21,"pre:",cell[p_x][p_y].pre_x,cell[p_x][p_y].pre_y);
    delay(200);
  }



}
